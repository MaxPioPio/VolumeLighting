#include "renderwidget.hpp"

#include "glutils.hpp"

// file paths for the shaders
static const bool FBO_FIX = true;

static float ROTATION_SPEED = 1.f, ROTATION_INTERVAL = 100 /*msec*/;


RenderWidget::RenderWidget(bool perspective)
{
	touchPos = QPoint();
	touchPrev = QPoint();
    touchPosS = QPoint();
    touchPrevS = QPoint();

    camera = new Camera();
    camera->setProjection(perspective, 0.1f, 1000.f, 60.f);

    scene = nullptr;
    // the renderers will be created in the OpenGL initialization
    primRenderer = nullptr;
    volumeRenderer = nullptr;

    selected = false;

    //timer for the automatic camera rotation
    rotationTimer = new QTimer(this);
    connect(rotationTimer, SIGNAL(timeout()), this, SLOT(rotationTimerEnd()));
    rotationTimer->setInterval(ROTATION_INTERVAL);
    rotationTimer->setSingleShot(false);
}


RenderWidget::~RenderWidget()
{
    delete camera;
    delete primRenderer;
    delete volumeRenderer;
}

void RenderWidget::setScene(Scene* scene) {
    this->scene = scene;
}


void RenderWidget::select() {
    selected = true;
}

void RenderWidget::deselect() {
    selected = false;
}

/// OPEN-GL ----------------------------------- ///

void RenderWidget::initializeGL()
{
    // obtain OpenGL 4 Core functions
    GLUtils::obtainOGlFunc(context());
    if (!GLUtils::glFunc()->initializeOpenGLFunctions())
    {
        qCritical("Couldn't initialize OpenGLFunctions!");
    }

    // create the renderers
    primRenderer = new PrimitiveUtils();
    volumeRenderer = new VolumeRenderer(this, scene->getVolume(), scene->getVolumeRenderProps(), width(), height());
    connect(scene->getVolumeRenderProps(), SIGNAL(shadowPropsChanged()), volumeRenderer, SLOT(shadowPropsChanged()));

    // set up open gl state -------------------------------------------------------------- //
    glClearColor(0.5f, 0.5f, 0.6f, 0.f);

    // enable depth test
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);

	// enable culling
	glEnable(GL_CULL_FACE);
	glFrontFace(GL_CCW);
	glCullFace(GL_BACK);
}

void RenderWidget::resizeGL(int width, int height)
{
	// update the viewport
    glViewport(0, 0, width, height);

    // update the projection matrix
    camera->resizeFrame(width, height);

    // update the renderer canvas (fbo)
    volumeRenderer->resizeCanvas(width, height);
}

void RenderWidget::paintGL()
{
    // call the volume renderer method
    volumeRenderer->render(camera, primRenderer);
}

void RenderWidget::setCamera(Camera *camera) {
    this->camera = camera;
}

Camera* RenderWidget::getCamera() {
    return camera;
}

/// MOUSE INPUT ------------------------------------------------ ///
/* This class stores the screen and world positions of the cursor
 * from the last and current frame. Therefore it also calculates
 * world from screen positions and vice versa.
 * The end behaviour generated by the input is solely controlled
 * by the conroller singleton. The stored positions are passed to
 * its corresponding input methods.                             */

QPointF RenderWidget::screenToWorld(QPointF p) {

    // get the z position of the cube on screen
    QVector3D translation = camera->getPosition();

    // calculate the matrix for the unprojection
    QMatrix4x4 unprojectMat = QMatrix4x4();
    unprojectMat.translate(translation.x(), translation.y(), translation.z());
    unprojectMat = *(camera->getProjectionMatrix()) * *(camera->getViewMatrix());
    unprojectMat = unprojectMat.inverted();

    // unproject the screen position
    QVector4D pos(p.x(), p.y(), 0.99f, 1.f);
    QVector4D result = unprojectMat * pos;
    result /= result.w();

    return QPointF(result.x(), result.y());
}


void RenderWidget::mousePressEvent(QMouseEvent *event)
{
	// store the position of the pointer for further calculations
    touchPosS = event->pos();
    touchPosS.setX(-1.f + 2.f * touchPosS.x() / width());
    touchPosS.setY(1.f - 2.f * touchPosS.y() / height());
    touchPos = screenToWorld(touchPosS);
	touchPrev = touchPos;
    touchPrevS = touchPosS;

    Controller::get()->mousePress(this, touchPosS, touchPos);

    emit clickedInside();
}

void RenderWidget::mouseReleaseEvent(QMouseEvent *event)
{
    // store the position of the pointer for further calculations
    touchPosS = event->pos();
    touchPosS.setX(-1.f + 2.f * touchPosS.x() / width());
    touchPosS.setY(1.f - 2.f * touchPosS.y() / height());
    touchPos = screenToWorld(touchPosS);
    touchPrev = touchPos;
    touchPrevS = touchPosS;

    if(FBO_FIX)
        update();

    Controller::get()->mouseRelease(this, touchPosS, touchPos);
}


void RenderWidget::mouseMoveEvent(QMouseEvent *event)
{
	// abort when no (relevant) button is pressed
	if (! ((event->buttons() & Qt::MouseButton::LeftButton) | (event->buttons() & Qt::MouseButton::RightButton)) )
		return;

	// update and store the new mouse pointer position
    touchPrevS = touchPosS;
    touchPosS = event->pos();
    touchPosS.setX(-1.f + 2.f * touchPosS.x() / width());
    touchPosS.setY(1.f - 2.f * touchPosS.y() / height());
	touchPrev = touchPos;
    touchPos = screenToWorld(touchPosS);

	// calculate the difference between the last and current mouse position
	QLineF delta = QLineF(touchPrev, touchPos);
    QLineF deltaS = QLineF(touchPrevS, touchPosS);
    Controller::get()->mouseMove(this, deltaS, delta, event->buttons() & Qt::MouseButton::LeftButton, event->modifiers());
}

void RenderWidget::wheelEvent(QWheelEvent *e) {
    Controller::get()->mouseWheel(this, e->delta(), e->modifiers());
}

/// SLOTS ------------------------------- ///
void RenderWidget::homePosition() {
    camera->resetPosition();
	update();
}

void RenderWidget::toggleCameraRotation() {
    if(rotationTimer->isActive())
        rotationTimer->stop();
    else
        rotationTimer->start();
}

void RenderWidget::rotationTimerEnd() {
    camera->rotate(QQuaternion::fromAxisAndAngle(0.f, 1.f, 0.f, ROTATION_SPEED));
    update();
}
